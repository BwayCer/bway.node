<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: nodeWaiter.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: nodeWaiter.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*! Node Waiter @license: CC-BY-4.0 - BwayCer (https://bwaycer.github.io/about/) */

/**
 * 節點服務生 Node Waiter
 *
 * @file
 * @author 張本微
 * @license CC-BY-4.0
 * @see [個人網站]{@link https://bwaycer.github.io/about/}
 */

"use strict";


/**
 * 節點服務生
 *
 * @module nodeWaiter
 */

module.exports = function ( _makeupRequire, _makeupEval, _makeupEvalfn, fnGetParseScript ) {
    let _parseScript = fnGetParseScript();

    /**
     * 解析參數。
     * &lt;br>
     * 帶入的參數見 {@link module:nodeWaiter~_parseArgs} 。
     *
     * @memberof module:nodeWaiter.
     * @func nodeWaiter
     */

    /**
     * 解析參數。
     *
     * @memberof module:nodeWaiter~
     * @func _parseArgs
     * @param {String} method - 採用讀取的方式。 有效值： `require`、`eval`、`evalfn` 。
     * @param {Array} packs - 打包清單。
     * @param {Array} [nodeModules] - 節點模組清單。
     * @param {Function} [done] - 回調函式。
     *
     * @example
     * // [ method, packs, null, null ]
     * nodeWaiter( strMethod, arrPacks );
     *
     * // [ method, packs, null, done ]
     * nodeWaiter( strMethod, arrPacks, fnChoC );
     *
     * // [ method, packs, nodeModules, null ]
     * nodeWaiter( strMethod, arrPacks, arrChoC );
     *
     * // [ method, packs, nodeModules, done ]
     * nodeWaiter( strMethod, arrPacks, arrChoC, fnChoD );
     */
    return function nodeWaiter( strMethod, arrPacks, arrNodeModules, fnDone ) {
        module.exports = null;

        if ( !arrPacks || arrPacks.constructor !== Array ) return;

        let isNullForDone = fnDone == null;

        if ( arrNodeModules == null &amp;&amp; isNullForDone ) {
            process.nextTick( _handleInit, strMethod, arrPacks, null, null );
        } else if ( typeof arrNodeModules === 'function' &amp;&amp; isNullForDone ) {
            fnDone = arrNodeModules;
            process.nextTick( _handleInit, strMethod, arrPacks, null, fnDone );
        } else if (
            arrNodeModules &amp;&amp; arrNodeModules.constructor === Array
            &amp;&amp; ( isNullForDone || typeof fnDone === 'function' )
        ) {
            process.nextTick( _handleInit, strMethod, arrPacks, arrNodeModules, fnDone );
        }
    };

    /**
     * 處理初始化。
     * &lt;br>
     * 帶入的參數見 {@link module:nodeWaiter~_parseArgs} 。
     *
     * @memberof module:nodeWaiter~
     * @func _handleInit
     */
    function _handleInit( strMethod, arrPacks, arrNodeModules, fnDone ) {
        let defaultCache = require( './initJS' ).cache;

        if ( arrNodeModules ) {
            let p, len, val;
            for ( p = 0, len = arrNodeModules.length; p &lt; len ; p++ ) {
                val = arrNodeModules[ p ];
                defaultCache[ val ] = require( val );
            }
        }

        let insWaiter = new defaultCache[ '/pure/internWaiter' ]( defaultCache );

        switch ( strMethod ) {
            case 'require': _makeupRequire( insWaiter ); break;
            case 'eval': _makeupEval( insWaiter, _parseScript ); break;
            case 'evalfn': _makeupEvalfn( insWaiter, _parseScript ); break;
        }

        insWaiter.order.pack( arrPacks, fnDone );
    }
}(
// _makeup_require
function ( insWaiter ) {
    global.order = insWaiter.order;

    insWaiter.request = function ( objQueryString, strId, fnDone ) {
        if ( !objQueryString.commonjs &amp;&amp; strId[ 0 ] === '/' ) strId = '.' + strId;

        process.nextTick( fnDone, null, strId );
    };

    insWaiter.readEval = function ( objQuerString, fnOrder, txt ) {
        fnOrder( require( txt ) );
    };
},
// _makeup_eval
function ( insWaiter, _parseScript ) {
    const path = require( 'path' );

    _parseScript._parseJSSource = function ( fnOrder, strFilename, txtCode ) {
        let fnToScript = Function(
            'order', '__dirname', '__filename', '__txtProgrammingCode',
            'eval( __txtProgrammingCode );'
        );
        return fnToScript( fnOrder, path.dirname( strFilename ), strFilename, txtCode );
    };

    _parseScript.makeup( insWaiter );
},
// _makeup_evalfn
function ( insWaiter, _parseScript ) {
    const path = require( 'path' );

    _parseScript._parseJSSource = function ( fnOrder, strFilename, txtCode ) {
        let fnToScript = Function( 'order', '__dirname', '__filename', txtCode );
        return fnToScript( fnOrder, path.dirname( strFilename ), strFilename );
    };

    _parseScript.makeup( insWaiter );
},
/**
 * 解析腳本
 * &lt;br>&lt;br>
 * 特別給予 `eval`、`evalfn`
 * 等需要判斷路徑及讀取文件的解析腳本工具使用。
 * &lt;br>&lt;br>
 * 以 `vm` 模組實現遇到個大問題基礎工具（如： `Array`、`Object`、`console` ...）的不相同或不存在。
 *
 * @memberof module:nodeWaiter~
 * @namespace _parseScript
 */
function () {
    const path = require( 'path' );
    const fs = require( 'fs' );

    let _pwd = path.dirname( process.argv[ 1 ] );
    let _parseScript = {};

    /**
     * 組裝。
     *
     * @memberof module:nodeWaiter~_parseScript.
     * @func makeup
     * @param {module:initJS.internWaiter} waiter
     */
    _parseScript.makeup = function ( insWaiter ) {
        insWaiter.request = function ( objQueryString, strId, fnDone ) {
            if ( objQueryString.commonjs ) return process.nextTick( fnDone, null, strId );

            if ( strId[ 0 ] === '/' ) strId = _pwd + strId;

            _parseScript.getFileInfo( strId, function ( err, objFileInfo ) {
                let abortList = _parseScript.abortList;

                if ( ~abortList.indexOf( strId ) ) return abortList.receive( strId );

                if ( err ) return process.nextTick( fnDone, err, null );

                objQueryString.filename = objFileInfo.filename;
                objQueryString.extname = objFileInfo.ext;
                fs.readFile( objFileInfo.filename, 'utf8', function ( err, txt ) {
                    if ( ~abortList.indexOf( strId ) ) return abortList.receive( strId );

                    fnDone( err, txt );
                } );
            } );

            return strId;
        };

        insWaiter.abort = function ( anyRequestObject ) {
            _parseScript.abortList.push( anyRequestObject );
        };

        insWaiter.readEval = function ( objQueryString, fnOrder, txt ) {
            if ( objQueryString.commonjs ) return fnOrder( require( txt ) );

            _parseScript.source( fnOrder, objQueryString.filename, objQueryString.extname, txt );
        };
    };

    /**
     * 已被取消但通知未被接收的清單。
     *
     * @memberof module:nodeWaiter~_parseScript.
     * @var {Array} abortList
     */
    _parseScript.abortList = [];

    _parseScript.abortList.receive = function ( strId ) {
        let numIndex = this.indexOf( strId );

        if ( ~numIndex ) {
            let len = this.length - 1;

            while ( numIndex &lt; len ) this[ numIndex ] = this[ ++numIndex ];
            arrList.pop();
        }
    };

    /**
     * 取得文件資訊。
     *
     * @memberof module:nodeWaiter~_parseScript.
     * @func getFileInfo
     * @param {String} id - 識別碼（文件路徑）。
     * @param {Function} done - 回調函式。
     * @throws {Error} Not found File. （未發現文件）（由回調函式接收，未拋出）
     * @throws {Error} Not found File. (is distinguished "directory")
     * （未發現文件（提示： 該文件被判別為目錄））（（由回調函式接收，未拋出）
     * @throws {Error} The file can't be evaluated.
     * （文件無法被解析）（（由回調函式接收，未拋出）
     */
    _parseScript.getFileInfo = function ( strId, fnDone ) {
        let self = this;

        fs.exists( strId, function ( bisExists ) {
            let abortList = self.abortList;

            if ( ~abortList.indexOf( strId ) ) return abortList.receive( strId );

            let strFileName = strId;

            if ( !bisExists ) return self._resolveFileName( strFileName, fnDone, 'Not found File.' );

            fs.stat( strFileName, function ( err, objStat ) {
                if ( ~abortList.indexOf( strId ) ) return abortList.receive( strId );

                if ( err ) return process.nextTick( fnDone, err, null );

                if ( objStat.isDirectory() ) {
                    self._resolveFileName(
                        path.join( strFileName, 'index' ),
                        fnDone,
                        'Not found File. (is distinguished "directory")'
                    );
                } else {
                    let ext = path.extname( strFileName );

                    if ( ~self._allowExtNameList.indexOf( ext ) ) {
                        process.nextTick( fnDone, null, { filename: strFileName, ext: ext } );
                    } else {
                        process.nextTick(
                            fnDone,
                            Error( 'The file can\'t be evaluated.' ),
                            null
                        );
                    }
                }
            } );
        } );
    };

    /**
     * 允許的擴展名： 接受 `.js`、`.json`、`.node` 等擴展名。
     * &lt;br>
     * 協助 {@link module:nodeWaiter~_parseScript._resolveFileName|_parseScript._resolveFileName}
     * 、 {@link module:nodeWaiter~_parseScript.getFileInfo|_parseScript.getFileInfo}
     * 的工具。
     *
     * @memberof module:nodeWaiter~_parseScript.
     * @var {Array} _allowExtNameList
     */
    _parseScript._allowExtNameList = [ '.js', '.json', '.node' ];

    /**
     * 解析文件路徑。
     * &lt;br>
     * 協助 {@link module:nodeWaiter~_parseScript.getFileInfo|_parseScript.getFileInfo}
     * 的工具。
     *
     * @memberof module:nodeWaiter~_parseScript.
     * @func _resolveFileName
     * @param {String} fileName - 文件路徑。
     * @param {Function} done - 回調函式。
     * @param {String} errMsg - 錯誤訊息。
     */
    _parseScript._resolveFileName = function( strFileName, fnDone, strErrMsg ) {
        let p, len, ext, path;
        let extList = this._allowExtNameList;

        for ( p = 0, len = extList.length; p &lt; len ; p++ ) {
            ext = extList[ p ];
            path = strFileName + ext;
            if( fs.existsSync( path ) )
                return process.nextTick( fnDone, null, { filename: path, ext: ext } );
        }

        process.nextTick( fnDone, Error( strErrMsg ), null );
    };

    /**
     * 源始碼： 解析源始碼。
     *
     * @memberof module:nodeWaiter~_parseScript.
     * @func source
     * @param {module:initJS.internWaiter#order} order
     * @param {String} fileName - 文件路徑。
     * @param {String} extName - 文件擴展名。
     * @param {String} txtCode - 文件程式碼。
     */
    _parseScript.source = function ( fnOrder, strFilename, strExtName, txtCode ) {
        switch ( strExtName ) {
            case '.js':
                this._parseJSSource( fnOrder, strFilename, txtCode );
                break;
            case '.json':
                fnOrder( JSON.parse( txtCode ) );
                break;
            case '.node':
                fnOrder( require( txtCode ) );
                break;
        }
    };

    /**
     * 解析爪哇腳本源碼： 將爪哇腳本文件由文字轉為可用的物件。
     *
     * @abstract
     * @memberof module:nodeWaiter~_parseScript.
     * @func _parseJSSource
     * @param {module:initJS.internWaiter#order} order。
     * @param {String} fileName - 文件路徑。
     * @param {String} txtCode - 文件程式碼。
     * @return {*}
     */

    return _parseScript;
}
);

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-initJS.html">initJS</a></li><li><a href="module-nodeWaiter.html">nodeWaiter</a></li></ul><h3>Classes</h3><ul><li><a href="module-initJS.internWaiter.html">internWaiter</a></li><li><a href="module-initJS.internWaiter-_infoForm.html">_infoForm</a></li><li><a href="module-initJS.internWaiter-_infoFormForPass.html">_infoFormForPass</a></li><li><a href="module-initJS.logNeedle.html">logNeedle</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-nodeWaiter-_parseScript.html">_parseScript</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.2</a> on Mon Jul 03 2017 20:11:37 GMT+0800 (CST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
